var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TuringGLM","category":"page"},{"location":"#TuringGLM","page":"Home","title":"TuringGLM","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TuringGLM.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TuringGLM]","category":"page"},{"location":"#TuringGLM.And1","page":"Home","title":"TuringGLM.And1","text":"And1 <: FormulaRewrite\n\nRemove numbers from interaction terms, so 1&x becomes &(x) (which is later cleaned up by EmptyAnd).\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.AssociativeRule","page":"Home","title":"TuringGLM.AssociativeRule","text":"struct AssociativeRule <: FormulaRewrite end\n\nApply associative rule: if in an expression headed by an associative operator (+,&,*) and the sub-expression child_idx is headed by the same operator, splice that child's children into it's location.\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.CategoricalTerm","page":"Home","title":"TuringGLM.CategoricalTerm","text":"CategoricalTerm{C,T,N} <: AbstractTerm\n\nRepresents a categorical term, with a name and TuringGLM.ContrastsMatrix\n\nFields\n\nsym::Symbol: The name of the variable\ncontrasts::ContrastsMatrix: A contrasts matrix that captures the unique values this variable takes on and how they are mapped onto numerical predictors.\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.ConstantTerm","page":"Home","title":"TuringGLM.ConstantTerm","text":"ConstantTerm{T<:Number} <: AbstractTerm\n\nRepresents a literal number in a formula.  By default will be converted to [TuringGLM.InterceptTerm] by TuringGLM.apply_schema.\n\nFields\n\nn::T: The number represented by this term.\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.ContinuousTerm","page":"Home","title":"TuringGLM.ContinuousTerm","text":"ContinuousTerm <: AbstractTerm\n\nRepresents a continuous variable, with a name and summary statistics.\n\nFields\n\nsym::Symbol: The name of the variable\nmean::T: Mean\nvar::T: Variance\nmin::T: Minimum value\nmax::T: Maximum value\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.ContrastsMatrix-Union{Tuple{T}, Tuple{C}, Tuple{C, AbstractVector{T}}} where {C<:TuringGLM.AbstractContrasts, T}","page":"Home","title":"TuringGLM.ContrastsMatrix","text":"ContrastsMatrix(contrasts::AbstractContrasts, levels::AbstractVector)\nContrastsMatrix(contrasts_matrix::ContrastsMatrix, levels::AbstractVector)\n\nAn instantiation of a contrast coding system for particular levels\n\nThis type is used internally for generating model matrices based on categorical data, and most users will not need to deal with it directly.  Conceptually, a ContrastsMatrix object stands for an instantiation of a contrast coding system for a particular set of categorical data levels.\n\nIf levels are specified in the AbstractContrasts, those will be used, and likewise for the base level (which defaults to the first level).\n\nConstructors\n\nContrastsMatrix(contrasts::AbstractContrasts, levels::AbstractVector)\nContrastsMatrix(contrasts_matrix::ContrastsMatrix, levels::AbstractVector)\n\nArguments\n\ncontrasts::AbstractContrasts: The contrast coding system to use.  We only use DummyCoding()\nlevels::AbstractVector: The levels to generate contrasts for.\ncontrasts_matrix::ContrastsMatrix: Constructing a ContrastsMatrix from another will check that the levels match.  This is used, for example, in constructing a model matrix from a ModelFrame using different data.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.Distributive","page":"Home","title":"TuringGLM.Distributive","text":"struct Distributive <: FormulaRewrite end\n\nDistributive propery: &(a..., +(b...), c...) to +(&(a..., b_i, c...)_i...). Replace outer call (:&) with inner call (:+), whose arguments are copies of the outer call, one for each argument of the inner call.  For the ith new child, the original inner call is replaced with the ith argument of the inner call.\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.DummyCoding","page":"Home","title":"TuringGLM.DummyCoding","text":"DummyCoding([base[, levels]])\nDummyCoding(; base=nothing, levels=nothing)\n\nDummy coding generates one indicator column (1 or 0) for each non-base level.\n\nIf levels are omitted or nothing, they are determined from the data by calling the levels function on the data when constructing ContrastsMatrix. If base is omitted or nothing, the first level is used as the base.\n\nColumns have non-zero mean and are collinear with an intercept column (and lower-order columns for interactions) but are orthogonal to each other. In a regression model, dummy coding leads to an intercept that is the mean of the dependent variable for base level.\n\nAlso known as \"treatment coding\" or \"one-hot encoding\".\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.FormulaRewrite","page":"Home","title":"TuringGLM.FormulaRewrite","text":"abstract type FormulaRewrite end\n\nFormula parsing is expressed as a bunch of expression re-writes, each of which is a subtype of FormulaRewrite.  There are two methods that dispatch on these types: applies(ex, child_idx, rule::Type{<:FormulaRewrite}) checks whether the re-write rule needs to be applied at argument child_idx of expression ex, and rewrite!(ex, child_idx, rule::Type{<:FormulaRewrite}) re-writes ex according to rule at position child_idx, and returns the next child_idx that needs to be checked.\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.FormulaTerm","page":"Home","title":"TuringGLM.FormulaTerm","text":"FormulaTerm{L,R} <: AbstractTerm\n\nRepresents an entire formula, with a left- and right-hand side.  These can be of any type (captured by the type parameters).\n\nFields\n\nlhs::L: The left-hand side (e.g., response)\nrhs::R: The right-hand side (e.g., predictors)\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.FullDummyCoding","page":"Home","title":"TuringGLM.FullDummyCoding","text":"FullDummyCoding()\n\nFull-rank dummy coding generates one indicator (1 or 0) column for each level, including the base level. This is sometimes known as one-hot encoding.\n\nNeeded internally for some situations where a categorical variable with k levels needs to be converted into k model matrix columns instead of the standard k-1.\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.InteractionTerm","page":"Home","title":"TuringGLM.InteractionTerm","text":"InteractionTerm{Ts} <: AbstractTerm\n\nRepresents an interaction between two or more individual terms. Generated by combining multiple AbstractTerms with & (which is what calls to & in a @formula lower to)\n\nFields\n\nterms::Ts: the terms that participate in the interaction.\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.InterceptTerm","page":"Home","title":"TuringGLM.InterceptTerm","text":"InterceptTerm{HasIntercept} <: AbstractTerm\n\nRepresents the presence or (explicit) absence of an \"intercept\" term in a regression model.  These terms are generated from TuringGLM.ConstantTerms in a formula by TuringGLM.apply_schema(::ConstantTerm, schema). A 1 yields TuringGLM.InterceptTerm{true}, and 0 or -1 yield TuringGLM.InterceptTerm{false} (which explicitly omits an intercept for models which implicitly includes one via the TuringGLM.implicit_intercept trait).\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.MatrixTerm","page":"Home","title":"TuringGLM.MatrixTerm","text":"MatrixTerm{Ts} <: AbstractTerm\n\nA collection of terms that should be combined to produce a single numeric matrix.\n\nA matrix term is created by TuringGLM.data_fixed_effects from a tuple of terms using TuringGLM.collect_matrix_terms, which pulls out all the terms that are matrix terms as determined by the trait function TuringGLM.is_matrix_term, which is true by default for all AbstractTerms.\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.Schema","page":"Home","title":"TuringGLM.Schema","text":"Schema\n\nStruct that wraps a Dict mapping Terms to their concrete forms.  This exists mainly for dispatch purposes and to support possibly more sophisticated behavior in the future.\n\nA Schema behaves for all intents and purposes like an immutable Dict, and delegates the constructor as well as getindex, get, merge!, merge, keys, and haskey to the wrapped Dict.\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.Star","page":"Home","title":"TuringGLM.Star","text":"struct Star <: FormulaRewrite end\n\nExpand a*b to a + b + a&b (*(a,b) to +(a,b,&(a,b))).  Applies recursively to multiple * arguments, so needs a clean-up pass (from distributive/associative).\n\n\n\n\n\n","category":"type"},{"location":"#TuringGLM.Term","page":"Home","title":"TuringGLM.Term","text":"Term <: AbstractTerm\n\nA placeholder for a variable in a formula where the type (and necessary data invariants) is not yet known.  This will be converted to a TuringGLM.ContinuousTerm or TuringGLM.CategoricalTerm by TuringGLM.apply_schema.\n\nFields\n\nsym::Symbol: The name of the data column this term refers to.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:==-Union{Tuple{T}, Tuple{C}, Tuple{TuringGLM.ContrastsMatrix{C, T, U} where U, TuringGLM.ContrastsMatrix{C, T, U} where U}} where {C<:TuringGLM.AbstractContrasts, T}","page":"Home","title":"Base.:==","text":"Base.:(==)\n\nOnly check equality of matrix, termnames, and levels, and that the type is the same for the contrasts (values are irrelevant).  This ensures that the two will behave identically in creating modelmatrix columns.\n\n\n\n\n\n","category":"method"},{"location":"#Base.convert-Tuple{Type{TuringGLM.ContrastsMatrix{TuringGLM.FullDummyCoding, T, U} where {T, U}}, TuringGLM.ContrastsMatrix}","page":"Home","title":"Base.convert","text":"Promote contrasts matrix to full rank version\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.apply_schema-Tuple{Any, Any}","page":"Home","title":"TuringGLM.apply_schema","text":"apply_schema(t, schema::Schema)\n\nReturn a new term that is the result of applying schema to term t.\n\nWhen t is a ContinuousTerm or CategoricalTerm already, the term will be returned unchanged unless a matching term is found in the schema.  This allows selective re-setting of a schema to change the contrast coding or levels of a categorical term, or to change a continuous term to categorical or vice versa.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.apply_schema-Tuple{TuringGLM.ConstantTerm, TuringGLM.FullRank, Type}","page":"Home","title":"TuringGLM.apply_schema","text":"apply_schema(t::AbstractTerm, schema::TuringGLM.FullRank)\n\nApply a schema, under the assumption that when a less-than-full rank model matrix would be produced, categorical terms should be \"promoted\" to full rank (where a categorical variable with k levels would produce k columns, instead of k-1 in the standard contrast coding schemes).\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.center_predictors-Tuple{AbstractMatrix{T} where T}","page":"Home","title":"TuringGLM.center_predictors","text":"center_predictors(X::AbstractMatrix)\n\nCenters the columns of a matrix X of predictors to mean 0.\n\nReturns a tuple with:\n\nμ_X: 1xK Matrix of Float64s of the means of the K columns in the original X\n\nmatrix.\n\nX_centered: A Matrix of Float64s with the same dimensions as the original matrix\n\nX with the columns centered on mean μ=0.\n\nArguments\n\nX::AbstractMatrix: a matrix of predictors where rows are observations and columns are\n\nvariables.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.checkcol-Tuple{Any, Symbol}","page":"Home","title":"TuringGLM.checkcol","text":"Return a nice-ish error message if the Symbol name isn't a column name in table, otherwise a zero-length string.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.checknamesexist-Tuple{TuringGLM.FormulaTerm, Any}","page":"Home","title":"TuringGLM.checknamesexist","text":"Check that each name in the given model f exists in the data source t and return a message if not. Return a zero string otherwise. t is something that implements the Tables interface.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.coefnames-Tuple{TuringGLM.FormulaTerm}","page":"Home","title":"TuringGLM.coefnames","text":"coefnames(term::AbstractTerm)\n\nReturn the name(s) of column(s) generated by a term.  Return value is either a String or an iterable of Strings.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.collect_matrix_terms-Tuple{Tuple{Union{Tuple{TuringGLM.AbstractTerm, Vararg{TuringGLM.AbstractTerm, N} where N}, TuringGLM.AbstractTerm}, Vararg{Union{Tuple{TuringGLM.AbstractTerm, Vararg{TuringGLM.AbstractTerm, N} where N}, TuringGLM.AbstractTerm}, N} where N}}","page":"Home","title":"TuringGLM.collect_matrix_terms","text":"collect_matrix_terms(ts::TupleTerm)\ncollect_matrix_terms(t::AbstractTerm) = collect_matrix_term((t, ))\n\nDepending on whether the component terms are matrix terms (meaning they have is_matrix_term(T) == true), collect_matrix_terms will return\n\nA single MatrixTerm (if all components are matrix terms)\nA tuple of the components (if none of them are matrix terms)\nA tuple of terms, with all matrix terms collected into a single MatrixTerm  in the first element of the tuple, and the remaining non-matrix terms passed  through unchanged.\n\nBy default all terms are matrix terms (that is, is_matrix_term(::Type{<:AbstractTerm}) = true), the first case is by far the most common.  The others are provided only for convenience when dealing with specialized terms that can't be concatenated into a single model matrix, like random-effects terms.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.concrete_term-Tuple{TuringGLM.Term, Any, Dict{Symbol, V} where V}","page":"Home","title":"TuringGLM.concrete_term","text":"concrete_term(t::Term, data[, hint])\n\nCreate concrete term from the placeholder t based on a data source and optional hint.  If data is a table, the getproperty is used to extract the appropriate column.\n\nThe hint can be a Dict{Symbol} of hints, or a specific hint, a concrete term type (ContinuousTerm or CategoricalTerm), or an instance of some <:AbstractContrasts, in which case a CategoricalTerm will be created using those contrasts.\n\nIf no hint is provided (or hint==nothing), the eltype of the data is used: Numbers are assumed to be continuous, and all others are assumed to be categorical.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.data_fixed_effects-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D","page":"Home","title":"TuringGLM.data_fixed_effects","text":"data_fixed_effects(formula::FormulaTerm, data)\n\nConstructs the matrix X of fixed-effects (a.k.a. population-level) predictors.\n\nReturns a Matrix of the fixed-effects predictors variables in the formula and present inside data.\n\nArguments\n\nformula: a FormulaTerm created by @formula macro.\ndata:  a data object that satisfies the\n\nTables.jl interface such as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.data_random_effects-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D","page":"Home","title":"TuringGLM.data_random_effects","text":"data_random_effects(formula::FormulaTerm, data)\n\nConstructs the matrix(ces) Z(s) of random-effects (a.k.a. group-level) predictors.\n\nReturns a Tuple of Matrix of the random-effects predictors variables in the formula and present inside data.\n\nArguments\n\nformula: a FormulaTerm created by @formula macro.\ndata:  a data object that satisfies the\n\nTables.jl interface such as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.data_response-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D","page":"Home","title":"TuringGLM.data_response","text":"data_response(formula::FormulaTerm, data)\n\nConstructs the response y vector.\n\nReturns a Vector of the response variable in the formula and present inside data.\n\nArguments\n\nformula: a FormulaTerm created by @formula macro.\ndata:  a data object that satisfies the\n\nTables.jl interface such as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.fuzzymatch-Tuple{Any, Symbol}","page":"Home","title":"TuringGLM.fuzzymatch","text":"This is borrowed from DataFrames.jl.  Return between 0 and 2 names from colnames closest to name. colnames : some iterable collection of symbols\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.has_schema-Tuple{TuringGLM.AbstractTerm}","page":"Home","title":"TuringGLM.has_schema","text":"has_schema(t::T) where {T<:AbstractTerm}\n\nReturn true if t has a schema, meaning that apply_schema would be a no-op.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.is_matrix_term-Tuple{T} where T","page":"Home","title":"TuringGLM.is_matrix_term","text":"is_matrix_term(::Type{<:AbstractTerm})\n\nDoes this type of term get concatenated with other matrix terms into a single model matrix?  This controls the behavior of the TuringGLM.collect_matrix_terms, which collects all of its arguments for which is_matrix_term returns true into a TuringGLM.MatrixTerm, and returns the rest unchanged.\n\nSince all \"normal\" terms which describe one or more model matrix columns are matrix terms, this defaults to true for any AbstractTerm. An example of a non-matrix term is a random-effect term TuringGLM.RandomEffectTerm.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.schema","page":"Home","title":"TuringGLM.schema","text":"schema([terms::AbstractVector{<:AbstractTerm}, ]data, hints::Dict{Symbol})\nschema(term::AbstractTerm, data, hints::Dict{Symbol})\n\nCompute all the invariants necessary to fit a model with terms.  A schema is a dict that maps Terms to their concrete instantiations (either CategoricalTerms or ContinuousTerms.  \"Hints\" may optionally be supplied in the form of a Dict mapping term names (as Symbols) to term or contrast types.  If a hint is not provided for a variable, the appropriate term type will be guessed based on the data type from the data column: any numeric data is assumed to be continuous, and any non-numeric data is assumed to be categorical.\n\nReturn a TuringGLM.Schema, which is a wrapper around a Dict mapping Terms to their concrete instantiations (ContinuousTerm or CategoricalTerm).\n\n\n\n\n\n","category":"function"},{"location":"#TuringGLM.standardize_predictors-Tuple{AbstractMatrix{T} where T}","page":"Home","title":"TuringGLM.standardize_predictors","text":"standardize_predictors(X::AbstractMatrix)\n\nStandardizes the columns of a matrix X of predictors to mean 0 and standard deviation 1.\n\nReturns a tuple with:\n\nμ_X: 1xK Matrix of Float64s of the means of the K columns in the original X\n\nmatrix.\n\nσ_X: 1xK Matrix of Float64s of the standard deviations of the K columns in the\n\noriginal X matrix.\n\nX_std: A Matrix of Float64s with the same dimensions as the original matrix\n\nX with the columns centered on mean μ=0 and standard deviation σ=1.\n\nArguments\n\nX::AbstractMatrix: a matrix of predictors where rows are observations and columns are\n\nvariables.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.term-Tuple{Number}","page":"Home","title":"TuringGLM.term","text":"term(x)\n\nWrap argument in an appropriate AbstractTerm type: Symbols and AbstractStrings become Terms, and Numbers become ConstantTerms.  Any AbstractTerms are unchanged. AbstractStrings are converted to symbols before wrapping.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.termsyms-Tuple{TuringGLM.AbstractTerm}","page":"Home","title":"TuringGLM.termsyms","text":"termsyms(t::Terms.Term)\n\nExtract the set of symbols referenced in this term. This is needed in order to determine when a categorical term should have standard (reduced rank) or full rank contrasts, based on the context it occurs in and the other terms that have already been encountered.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.termvars-Tuple{TuringGLM.AbstractTerm}","page":"Home","title":"TuringGLM.termvars","text":"termvars(t::AbstractTerm)\n\nThe data variables that this term refers to.\n\n\n\n\n\n","category":"method"},{"location":"#TuringGLM.@formula-Tuple{Any}","page":"Home","title":"TuringGLM.@formula","text":"@formula(ex)\n\nCapture and parse a formula expression as a Formula struct.\n\nA formula is an abstract specification of a dependence between left-hand and right-hand side variables as in, e.g., a regression model.  Each side specifies at a high level how tabular data is to be converted to a numerical matrix suitable for modeling.  This specification looks something like Julia code, is represented as a Julia Expr, but uses special syntax.  The @formula macro takes an expression like y ~ a*b, transforms it according to the formula syntax rules into a lowered form (like y ~ a + b + a&b), and constructs a Formula struct which captures the original expression, the lowered expression, and the left- and right-hand-side.\n\nOperators that have special interpretations in this syntax are\n\n~ is the formula separator, where it is a binary operator (the first argument is the left-hand side, and the second is the right-hand side.\n+ concatenates variables as columns when generating a model matrix.\n& representes an interaction between two or more variables, which corresponds to a row-wise kronecker product of the individual terms (or element-wise product if all terms involved are continuous/scalar).\n* expands to all main effects and interactions: a*b is equivalent to a+b+a&b, a*b*c to a+b+c+a&b+a&c+b&c+a&b&c, etc.\n1, 0, and -1 indicate the presence (for 1) or absence (for 0 and -1) of an intercept column.\n\nThe rules that are applied are\n\nThe associative rule (un-nests nested calls to +, &, and *).\nThe distributive rule (interactions & distribute over concatenation +).\nThe * rule expands a*b to a+b+a&b (recursively).\nSubtraction is converted to addition and negation, so x-1 becomes x + -1 (applies only to subtraction of literal 1).\nSingle-argument & calls are stripped, so &(x) becomes the main effect x.\n\n\n\n\n\n","category":"macro"}]
}
