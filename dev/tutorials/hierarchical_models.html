<!-- PlutoStaticHTML.Begin -->
<!--
    # This information is used for caching.
    [PlutoStaticHTML.State]
    input_sha = "63f61b21aeec84418409671b11c988f589badd28bf266587a694783593546cad"
    julia_version = "1.6.5"
-->




<div class="markdown"><p>Currently, TuringGLM only supports hierarchical models with a single random-intercept. This is done by using the <code>&#40;1 | group&#41;</code> inside the <code>@formula</code> macro.</p>
<p>For our <strong>Hierarchical Model</strong> example, let&#39;s use a famous dataset called <code>cheese</code> &#40;Boatwright, McCulloch &amp; Rossi, 1999&#41;, which is data from cheese ratings. A group of 10 rural and 10 urban raters rated 4 types of different cheeses &#40;A, B, C and D&#41; in two samples. So we have <span class="tex">$4 \cdot 20 \cdot 2 &#61; 160$</span> observations and 4 variables:</p>
<ul>
<li><p><code>cheese</code>: type of cheese from <code>A</code> to <code>D</code></p>
</li>
<li><p><code>rater</code>: id of the rater from <code>1</code> to <code>10</code></p>
</li>
<li><p><code>background</code>: type of rater, either <code>rural</code> or <code>urban</code></p>
</li>
<li><p><code>y</code>: rating of the cheese</p>
</li>
</ul>
</div>

<pre><code class="language-julia">using CSV</code></pre>


<pre><code class="language-julia">using DataFrames</code></pre>


<pre><code class="language-julia">url = "https://github.com/TuringLang/TuringGLM.jl/raw/main/data/cheese.csv";</code></pre>


<pre><code class="language-julia">cheese = CSV.read(download(url), DataFrame)</code></pre>
<table>
<tr>
<th>cheese</th>
<th>rater</th>
<th>background</th>
<th>y</th>
</tr>
<tr>
<td>"A"</td>
<td>1</td>
<td>"rural"</td>
<td>67</td>
</tr>
<tr>
<td>"A"</td>
<td>1</td>
<td>"rural"</td>
<td>66</td>
</tr>
<tr>
<td>"B"</td>
<td>1</td>
<td>"rural"</td>
<td>51</td>
</tr>
<tr>
<td>"B"</td>
<td>1</td>
<td>"rural"</td>
<td>53</td>
</tr>
<tr>
<td>"C"</td>
<td>1</td>
<td>"rural"</td>
<td>75</td>
</tr>
<tr>
<td>"C"</td>
<td>1</td>
<td>"rural"</td>
<td>70</td>
</tr>
<tr>
<td>"D"</td>
<td>1</td>
<td>"rural"</td>
<td>68</td>
</tr>
<tr>
<td>"D"</td>
<td>1</td>
<td>"rural"</td>
<td>66</td>
</tr>
<tr>
<td>"A"</td>
<td>2</td>
<td>"rural"</td>
<td>76</td>
</tr>
<tr>
<td>"A"</td>
<td>2</td>
<td>"rural"</td>
<td>76</td>
</tr>
<tr>
<td>...</td>
</tr>
<tr>
<td>"D"</td>
<td>10</td>
<td>"urban"</td>
<td>83</td>
</tr>
</table>


<pre><code class="language-julia">using TuringGLM</code></pre>



<div class="markdown"><p>Using <code>y</code> as dependent variable and <code>background</code> is independent variable with a varying-intercept per <code>cheese</code> type:</p>
</div>

<pre><code class="language-julia">fm = @formula(y ~ (1 | cheese) + background)</code></pre>
<pre><code class="code-output">FormulaTerm
Response:
  y(unknown)
Predictors:
  (cheese)->1 | cheese
  background(unknown)</code></pre>


<div class="markdown"><p>We instantiate our model with <code>turing_model</code> without specifying any model, thus the default model will be used: <code>Gaussian&#40;&#41;</code></p>
</div>

<pre><code class="language-julia">model = turing_model(fm, cheese);</code></pre>


<pre><code class="language-julia">chn = sample(model, NUTS(), 2_000);</code></pre>


<pre><code class="language-julia">describe(chn)[1]</code></pre>
<table>
<tr>
<th>parameters</th>
<th>mean</th>
<th>std</th>
<th>naive_se</th>
<th>mcse</th>
<th>ess</th>
<th>rhat</th>
<th>ess_per_sec</th>
</tr>
<tr>
<td>:α</td>
<td>68.1503</td>
<td>5.50245</td>
<td>0.123038</td>
<td>0.225954</td>
<td>577.421</td>
<td>0.999502</td>
<td>8.29461</td>
</tr>
<tr>
<td>Symbol("β[1]")</td>
<td>6.89987</td>
<td>0.9572</td>
<td>0.0214036</td>
<td>0.0242747</td>
<td>1431.69</td>
<td>0.999935</td>
<td>20.5662</td>
</tr>
<tr>
<td>:σ</td>
<td>5.88769</td>
<td>0.254418</td>
<td>0.00568896</td>
<td>0.00602049</td>
<td>1572.45</td>
<td>1.0002</td>
<td>22.5882</td>
</tr>
<tr>
<td>:τ</td>
<td>11.7821</td>
<td>4.58883</td>
<td>0.102609</td>
<td>0.17653</td>
<td>607.279</td>
<td>1.00683</td>
<td>8.72352</td>
</tr>
<tr>
<td>Symbol("zⱼ[1]")</td>
<td>0.32241</td>
<td>0.492822</td>
<td>0.0110198</td>
<td>0.0203907</td>
<td>581.191</td>
<td>1.00001</td>
<td>8.34877</td>
</tr>
<tr>
<td>Symbol("zⱼ[2]")</td>
<td>-1.42124</td>
<td>0.657373</td>
<td>0.0146993</td>
<td>0.0232415</td>
<td>619.884</td>
<td>1.00287</td>
<td>8.90459</td>
</tr>
<tr>
<td>Symbol("zⱼ[3]")</td>
<td>0.784052</td>
<td>0.56081</td>
<td>0.0125401</td>
<td>0.0231927</td>
<td>611.067</td>
<td>1.00149</td>
<td>8.77794</td>
</tr>
<tr>
<td>Symbol("zⱼ[4]")</td>
<td>0.0842721</td>
<td>0.475274</td>
<td>0.0106274</td>
<td>0.0189922</td>
<td>573.656</td>
<td>0.999717</td>
<td>8.24053</td>
</tr>
</table>



<div class="markdown"><h2>References</h2>
<p>Boatwright, P., McCulloch, R., &amp; Rossi, P. &#40;1999&#41;. Account-level modeling for trade promotion: An application of a constrained parameter hierarchical model. Journal of the American Statistical Association, 94&#40;448&#41;, 1063–1073.</p>
</div>

<!-- PlutoStaticHTML.End -->