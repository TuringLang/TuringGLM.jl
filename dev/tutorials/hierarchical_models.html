<!-- PlutoStaticHTML.Begin -->
<!--
    # This information is used for caching.
    [PlutoStaticHTML.State]
    input_sha = "63f61b21aeec84418409671b11c988f589badd28bf266587a694783593546cad"
    julia_version = "1.6.5"
-->




<div class="markdown"><p>Currently, TuringGLM only supports hierarchical models with a single random-intercept. This is done by using the <code>&#40;1 | group&#41;</code> inside the <code>@formula</code> macro.</p>
<p>For our <strong>Hierarchical Model</strong> example, let&#39;s use a famous dataset called <code>cheese</code> &#40;Boatwright, McCulloch &amp; Rossi, 1999&#41;, which is data from cheese ratings. A group of 10 rural and 10 urban raters rated 4 types of different cheeses &#40;A, B, C and D&#41; in two samples. So we have <span class="tex">$4 \cdot 20 \cdot 2 &#61; 160$</span> observations and 4 variables:</p>
<ul>
<li><p><code>cheese</code>: type of cheese from <code>A</code> to <code>D</code></p>
</li>
<li><p><code>rater</code>: id of the rater from <code>1</code> to <code>10</code></p>
</li>
<li><p><code>background</code>: type of rater, either <code>rural</code> or <code>urban</code></p>
</li>
<li><p><code>y</code>: rating of the cheese</p>
</li>
</ul>
</div>

<pre><code class="language-julia">using CSV</code></pre>


<pre><code class="language-julia">using DataFrames</code></pre>


<pre><code class="language-julia">url = "https://github.com/TuringLang/TuringGLM.jl/raw/main/data/cheese.csv";</code></pre>


<pre><code class="language-julia">cheese = CSV.read(download(url), DataFrame)</code></pre>
<table>
<tr>
<th>cheese</th>
<th>rater</th>
<th>background</th>
<th>y</th>
</tr>
<tr>
<td>"A"</td>
<td>1</td>
<td>"rural"</td>
<td>67</td>
</tr>
<tr>
<td>"A"</td>
<td>1</td>
<td>"rural"</td>
<td>66</td>
</tr>
<tr>
<td>"B"</td>
<td>1</td>
<td>"rural"</td>
<td>51</td>
</tr>
<tr>
<td>"B"</td>
<td>1</td>
<td>"rural"</td>
<td>53</td>
</tr>
<tr>
<td>"C"</td>
<td>1</td>
<td>"rural"</td>
<td>75</td>
</tr>
<tr>
<td>"C"</td>
<td>1</td>
<td>"rural"</td>
<td>70</td>
</tr>
<tr>
<td>"D"</td>
<td>1</td>
<td>"rural"</td>
<td>68</td>
</tr>
<tr>
<td>"D"</td>
<td>1</td>
<td>"rural"</td>
<td>66</td>
</tr>
<tr>
<td>"A"</td>
<td>2</td>
<td>"rural"</td>
<td>76</td>
</tr>
<tr>
<td>"A"</td>
<td>2</td>
<td>"rural"</td>
<td>76</td>
</tr>
<tr>
<td>...</td>
</tr>
<tr>
<td>"D"</td>
<td>10</td>
<td>"urban"</td>
<td>83</td>
</tr>
</table>


<pre><code class="language-julia">using TuringGLM</code></pre>



<div class="markdown"><p>Using <code>y</code> as dependent variable and <code>background</code> is independent variable with a varying-intercept per <code>cheese</code> type:</p>
</div>

<pre><code class="language-julia">fm = @formula(y ~ (1 | cheese) + background)</code></pre>
<pre><code class="code-output">FormulaTerm
Response:
  y(unknown)
Predictors:
  (cheese)->1 | cheese
  background(unknown)</code></pre>


<div class="markdown"><p>We instantiate our model with <code>turing_model</code> without specifying any model, thus the default model will be used: <code>Gaussian&#40;&#41;</code></p>
</div>

<pre><code class="language-julia">model = turing_model(fm, cheese);</code></pre>


<pre><code class="language-julia">chn = sample(model, NUTS(), 2_000);</code></pre>


<pre><code class="language-julia">describe(chn)[1]</code></pre>
<table>
<tr>
<th>parameters</th>
<th>mean</th>
<th>std</th>
<th>naive_se</th>
<th>mcse</th>
<th>ess</th>
<th>rhat</th>
<th>ess_per_sec</th>
</tr>
<tr>
<td>:α</td>
<td>68.4286</td>
<td>5.20338</td>
<td>0.116351</td>
<td>0.241355</td>
<td>432.095</td>
<td>1.00058</td>
<td>6.60837</td>
</tr>
<tr>
<td>Symbol("β[1]")</td>
<td>6.88525</td>
<td>0.96812</td>
<td>0.0216478</td>
<td>0.0257207</td>
<td>1365.1</td>
<td>0.999532</td>
<td>20.8776</td>
</tr>
<tr>
<td>:σ</td>
<td>5.89516</td>
<td>0.276606</td>
<td>0.0061851</td>
<td>0.0082605</td>
<td>1006.04</td>
<td>0.999802</td>
<td>15.3862</td>
</tr>
<tr>
<td>:τ</td>
<td>11.7155</td>
<td>4.50236</td>
<td>0.100676</td>
<td>0.203149</td>
<td>445.523</td>
<td>1.00028</td>
<td>6.81374</td>
</tr>
<tr>
<td>Symbol("zⱼ[1]")</td>
<td>0.301826</td>
<td>0.476171</td>
<td>0.0106475</td>
<td>0.0197693</td>
<td>532.525</td>
<td>1.00259</td>
<td>8.14433</td>
</tr>
<tr>
<td>Symbol("zⱼ[2]")</td>
<td>-1.44788</td>
<td>0.641915</td>
<td>0.0143537</td>
<td>0.0224105</td>
<td>586.855</td>
<td>0.999681</td>
<td>8.97524</td>
</tr>
<tr>
<td>Symbol("zⱼ[3]")</td>
<td>0.765653</td>
<td>0.54885</td>
<td>0.0122727</td>
<td>0.0237413</td>
<td>547.23</td>
<td>1.00199</td>
<td>8.36923</td>
</tr>
<tr>
<td>Symbol("zⱼ[4]")</td>
<td>0.0628067</td>
<td>0.457955</td>
<td>0.0102402</td>
<td>0.0185694</td>
<td>524.722</td>
<td>1.00116</td>
<td>8.02499</td>
</tr>
</table>



<div class="markdown"><h2>References</h2>
<p>Boatwright, P., McCulloch, R., &amp; Rossi, P. &#40;1999&#41;. Account-level modeling for trade promotion: An application of a constrained parameter hierarchical model. Journal of the American Statistical Association, 94&#40;448&#41;, 1063–1073.</p>
</div>

<!-- PlutoStaticHTML.End -->