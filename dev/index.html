<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TuringGLM.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://TuringLang.github.io/TuringGLM.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TuringGLM.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/TuringLang/TuringGLM.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TuringGLM"><a class="docs-heading-anchor" href="#TuringGLM">TuringGLM</a><a id="TuringGLM-1"></a><a class="docs-heading-anchor-permalink" href="#TuringGLM" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/TuringLang/TuringGLM.jl">TuringGLM</a>.</p><ul><li><a href="#TuringGLM.And1"><code>TuringGLM.And1</code></a></li><li><a href="#TuringGLM.AssociativeRule"><code>TuringGLM.AssociativeRule</code></a></li><li><a href="#TuringGLM.CategoricalTerm"><code>TuringGLM.CategoricalTerm</code></a></li><li><a href="#TuringGLM.ConstantTerm"><code>TuringGLM.ConstantTerm</code></a></li><li><a href="#TuringGLM.ContinuousTerm"><code>TuringGLM.ContinuousTerm</code></a></li><li><a href="#TuringGLM.ContrastsMatrix-Union{Tuple{T}, Tuple{C}, Tuple{C, AbstractVector{T}}} where {C&lt;:TuringGLM.AbstractContrasts, T}"><code>TuringGLM.ContrastsMatrix</code></a></li><li><a href="#TuringGLM.Distributive"><code>TuringGLM.Distributive</code></a></li><li><a href="#TuringGLM.DummyCoding"><code>TuringGLM.DummyCoding</code></a></li><li><a href="#TuringGLM.FormulaRewrite"><code>TuringGLM.FormulaRewrite</code></a></li><li><a href="#TuringGLM.FormulaTerm"><code>TuringGLM.FormulaTerm</code></a></li><li><a href="#TuringGLM.FullDummyCoding"><code>TuringGLM.FullDummyCoding</code></a></li><li><a href="#TuringGLM.InteractionTerm"><code>TuringGLM.InteractionTerm</code></a></li><li><a href="#TuringGLM.InterceptTerm"><code>TuringGLM.InterceptTerm</code></a></li><li><a href="#TuringGLM.MatrixTerm"><code>TuringGLM.MatrixTerm</code></a></li><li><a href="#TuringGLM.Schema"><code>TuringGLM.Schema</code></a></li><li><a href="#TuringGLM.Star"><code>TuringGLM.Star</code></a></li><li><a href="#TuringGLM.Term"><code>TuringGLM.Term</code></a></li><li><a href="#Base.:==-Union{Tuple{T}, Tuple{C}, Tuple{TuringGLM.ContrastsMatrix{C, T, U} where U, TuringGLM.ContrastsMatrix{C, T, U} where U}} where {C&lt;:TuringGLM.AbstractContrasts, T}"><code>Base.:==</code></a></li><li><a href="#Base.convert-Tuple{Type{TuringGLM.ContrastsMatrix{TuringGLM.FullDummyCoding, T, U} where {T, U}}, TuringGLM.ContrastsMatrix}"><code>Base.convert</code></a></li><li><a href="#TuringGLM.apply_schema-Tuple{Any, Any}"><code>TuringGLM.apply_schema</code></a></li><li><a href="#TuringGLM.apply_schema-Tuple{TuringGLM.ConstantTerm, TuringGLM.FullRank, Type}"><code>TuringGLM.apply_schema</code></a></li><li><a href="#TuringGLM.center_predictors-Tuple{AbstractMatrix{T} where T}"><code>TuringGLM.center_predictors</code></a></li><li><a href="#TuringGLM.checkcol-Tuple{Any, Symbol}"><code>TuringGLM.checkcol</code></a></li><li><a href="#TuringGLM.checknamesexist-Tuple{TuringGLM.FormulaTerm, Any}"><code>TuringGLM.checknamesexist</code></a></li><li><a href="#TuringGLM.coefnames-Tuple{TuringGLM.FormulaTerm}"><code>TuringGLM.coefnames</code></a></li><li><a href="#TuringGLM.collect_matrix_terms-Tuple{Tuple{Union{Tuple{TuringGLM.AbstractTerm, Vararg{TuringGLM.AbstractTerm, N} where N}, TuringGLM.AbstractTerm}, Vararg{Union{Tuple{TuringGLM.AbstractTerm, Vararg{TuringGLM.AbstractTerm, N} where N}, TuringGLM.AbstractTerm}, N} where N}}"><code>TuringGLM.collect_matrix_terms</code></a></li><li><a href="#TuringGLM.concrete_term-Tuple{TuringGLM.Term, Any, Dict{Symbol, V} where V}"><code>TuringGLM.concrete_term</code></a></li><li><a href="#TuringGLM.data_fixed_effects-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D"><code>TuringGLM.data_fixed_effects</code></a></li><li><a href="#TuringGLM.data_random_effects-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D"><code>TuringGLM.data_random_effects</code></a></li><li><a href="#TuringGLM.data_response-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D"><code>TuringGLM.data_response</code></a></li><li><a href="#TuringGLM.fuzzymatch-Tuple{Any, Symbol}"><code>TuringGLM.fuzzymatch</code></a></li><li><a href="#TuringGLM.has_schema-Tuple{TuringGLM.AbstractTerm}"><code>TuringGLM.has_schema</code></a></li><li><a href="#TuringGLM.is_matrix_term-Tuple{T} where T"><code>TuringGLM.is_matrix_term</code></a></li><li><a href="#TuringGLM.schema"><code>TuringGLM.schema</code></a></li><li><a href="#TuringGLM.standardize_predictors-Tuple{AbstractMatrix{T} where T}"><code>TuringGLM.standardize_predictors</code></a></li><li><a href="#TuringGLM.term-Tuple{Number}"><code>TuringGLM.term</code></a></li><li><a href="#TuringGLM.termsyms-Tuple{TuringGLM.AbstractTerm}"><code>TuringGLM.termsyms</code></a></li><li><a href="#TuringGLM.termvars-Tuple{TuringGLM.AbstractTerm}"><code>TuringGLM.termvars</code></a></li><li><a href="#TuringGLM.@formula-Tuple{Any}"><code>TuringGLM.@formula</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.And1" href="#TuringGLM.And1"><code>TuringGLM.And1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">And1 &lt;: FormulaRewrite</code></pre><p>Remove numbers from interaction terms, so <code>1&amp;x</code> becomes <code>&amp;(x)</code> (which is later cleaned up by <code>EmptyAnd</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/formula.jl#L138-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.AssociativeRule" href="#TuringGLM.AssociativeRule"><code>TuringGLM.AssociativeRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AssociativeRule &lt;: FormulaRewrite end</code></pre><p>Apply associative rule: if in an expression headed by an associative operator (<code>+,&amp;,*</code>) and the sub-expression <code>child_idx</code> is headed by the same operator, splice that child&#39;s children into it&#39;s location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/formula.jl#L89-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.CategoricalTerm" href="#TuringGLM.CategoricalTerm"><code>TuringGLM.CategoricalTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CategoricalTerm{C,T,N} &lt;: AbstractTerm</code></pre><p>Represents a categorical term, with a name and <a href="#TuringGLM.ContrastsMatrix-Union{Tuple{T}, Tuple{C}, Tuple{C, AbstractVector{T}}} where {C&lt;:TuringGLM.AbstractContrasts, T}"><code>TuringGLM.ContrastsMatrix</code></a></p><p><strong>Fields</strong></p><ul><li><code>sym::Symbol</code>: The name of the variable</li><li><code>contrasts::ContrastsMatrix</code>: A contrasts matrix that captures the unique values this variable takes on and how they are mapped onto numerical predictors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/terms.jl#L117-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.ConstantTerm" href="#TuringGLM.ConstantTerm"><code>TuringGLM.ConstantTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantTerm{T&lt;:Number} &lt;: AbstractTerm</code></pre><p>Represents a literal number in a formula.  By default will be converted to [<code>TuringGLM.InterceptTerm</code>] by <a href="#TuringGLM.apply_schema-Tuple{Any, Any}"><code>TuringGLM.apply_schema</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>n::T</code>: The number represented by this term.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/terms.jl#L34-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.ContinuousTerm" href="#TuringGLM.ContinuousTerm"><code>TuringGLM.ContinuousTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuousTerm &lt;: AbstractTerm</code></pre><p>Represents a continuous variable, with a name and summary statistics.</p><p><strong>Fields</strong></p><ul><li><code>sym::Symbol</code>: The name of the variable</li><li><code>mean::T</code>: Mean</li><li><code>var::T</code>: Variance</li><li><code>min::T</code>: Minimum value</li><li><code>max::T</code>: Maximum value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/terms.jl#L94-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.ContrastsMatrix-Union{Tuple{T}, Tuple{C}, Tuple{C, AbstractVector{T}}} where {C&lt;:TuringGLM.AbstractContrasts, T}" href="#TuringGLM.ContrastsMatrix-Union{Tuple{T}, Tuple{C}, Tuple{C, AbstractVector{T}}} where {C&lt;:TuringGLM.AbstractContrasts, T}"><code>TuringGLM.ContrastsMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ContrastsMatrix(contrasts::AbstractContrasts, levels::AbstractVector)
ContrastsMatrix(contrasts_matrix::ContrastsMatrix, levels::AbstractVector)</code></pre><p>An instantiation of a contrast coding system for particular levels</p><p>This type is used internally for generating model matrices based on categorical data, and <strong>most users will not need to deal with it directly</strong>.  Conceptually, a <code>ContrastsMatrix</code> object stands for an instantiation of a contrast coding <em>system</em> for a particular set of categorical <em>data levels</em>.</p><p>If levels are specified in the <code>AbstractContrasts</code>, those will be used, and likewise for the base level (which defaults to the first level).</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ContrastsMatrix(contrasts::AbstractContrasts, levels::AbstractVector)
ContrastsMatrix(contrasts_matrix::ContrastsMatrix, levels::AbstractVector)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>contrasts::AbstractContrasts</code>: The contrast coding system to use.  We only use <code>DummyCoding()</code></p></li><li><p><code>levels::AbstractVector</code>: The levels to generate contrasts for.</p></li><li><p><code>contrasts_matrix::ContrastsMatrix</code>: Constructing a <code>ContrastsMatrix</code> from another will check that the levels match.  This is used, for example, in constructing a model matrix from a <code>ModelFrame</code> using different data.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/contrasts.jl#L37-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.Distributive" href="#TuringGLM.Distributive"><code>TuringGLM.Distributive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Distributive &lt;: FormulaRewrite end</code></pre><p>Distributive propery: <code>&amp;(a..., +(b...), c...)</code> to <code>+(&amp;(a..., b_i, c...)_i...)</code>. Replace outer call (:&amp;) with inner call (:+), whose arguments are copies of the outer call, one for each argument of the inner call.  For the ith new child, the original inner call is replaced with the ith argument of the inner call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/formula.jl#L110-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.DummyCoding" href="#TuringGLM.DummyCoding"><code>TuringGLM.DummyCoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DummyCoding([base[, levels]])
DummyCoding(; base=nothing, levels=nothing)</code></pre><p>Dummy coding generates one indicator column (1 or 0) for each non-base level.</p><p>If <code>levels</code> are omitted or <code>nothing</code>, they are determined from the data by calling the <code>levels</code> function on the data when constructing <code>ContrastsMatrix</code>. If <code>base</code> is omitted or <code>nothing</code>, the first level is used as the base.</p><p>Columns have non-zero mean and are collinear with an intercept column (and lower-order columns for interactions) but are orthogonal to each other. In a regression model, dummy coding leads to an intercept that is the mean of the dependent variable for base level.</p><p>Also known as &quot;treatment coding&quot; or &quot;one-hot encoding&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/contrasts.jl#L160-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.FormulaRewrite" href="#TuringGLM.FormulaRewrite"><code>TuringGLM.FormulaRewrite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type FormulaRewrite end</code></pre><p>Formula parsing is expressed as a bunch of expression re-writes, each of which is a subtype of <code>FormulaRewrite</code>.  There are two methods that dispatch on these types: <code>applies(ex, child_idx, rule::Type{&lt;:FormulaRewrite})</code> checks whether the re-write <code>rule</code> needs to be applied at argument <code>child_idx</code> of expression <code>ex</code>, and <code>rewrite!(ex, child_idx, rule::Type{&lt;:FormulaRewrite})</code> re-writes <code>ex</code> according to <code>rule</code> at position <code>child_idx</code>, and returns the next <code>child_idx</code> that needs to be checked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/formula.jl#L58-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.FormulaTerm" href="#TuringGLM.FormulaTerm"><code>TuringGLM.FormulaTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FormulaTerm{L,R} &lt;: AbstractTerm</code></pre><p>Represents an entire formula, with a left- and right-hand side.  These can be of any type (captured by the type parameters).</p><p><strong>Fields</strong></p><ul><li><code>lhs::L</code>: The left-hand side (e.g., response)</li><li><code>rhs::R</code>: The right-hand side (e.g., predictors)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/terms.jl#L48-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.FullDummyCoding" href="#TuringGLM.FullDummyCoding"><code>TuringGLM.FullDummyCoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FullDummyCoding()</code></pre><p>Full-rank dummy coding generates one indicator (1 or 0) column for each level, <strong>including</strong> the base level. This is sometimes known as <a href="https://en.wikipedia.org/wiki/One-hot">one-hot encoding</a>.</p><p>Needed internally for some situations where a categorical variable with <span>$k$</span> levels needs to be converted into <span>$k$</span> model matrix columns instead of the standard <span>$k-1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/contrasts.jl#L192-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.InteractionTerm" href="#TuringGLM.InteractionTerm"><code>TuringGLM.InteractionTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InteractionTerm{Ts} &lt;: AbstractTerm</code></pre><p>Represents an <em>interaction</em> between two or more individual terms. Generated by combining multiple <code>AbstractTerm</code>s with <code>&amp;</code> (which is what calls to <code>&amp;</code> in a <code>@formula</code> lower to)</p><p><strong>Fields</strong></p><ul><li><code>terms::Ts</code>: the terms that participate in the interaction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/terms.jl#L64-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.InterceptTerm" href="#TuringGLM.InterceptTerm"><code>TuringGLM.InterceptTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InterceptTerm{HasIntercept} &lt;: AbstractTerm</code></pre><p>Represents the presence or (explicit) absence of an &quot;intercept&quot; term in a regression model.  These terms are generated from <a href="#TuringGLM.ConstantTerm"><code>TuringGLM.ConstantTerm</code></a>s in a formula by <code>TuringGLM.apply_schema(::ConstantTerm, schema)</code>. A <code>1</code> yields <code>TuringGLM.InterceptTerm{true}</code>, and <code>0</code> or <code>-1</code> yield <code>TuringGLM.InterceptTerm{false}</code> (which explicitly omits an intercept for models which implicitly includes one via the <a href="@ref"><code>TuringGLM.implicit_intercept</code></a> trait).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/terms.jl#L81-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.MatrixTerm" href="#TuringGLM.MatrixTerm"><code>TuringGLM.MatrixTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatrixTerm{Ts} &lt;: AbstractTerm</code></pre><p>A collection of terms that should be combined to produce a single numeric matrix.</p><p>A matrix term is created by <a href="#TuringGLM.data_fixed_effects-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D"><code>TuringGLM.data_fixed_effects</code></a> from a tuple of terms using <a href="#TuringGLM.collect_matrix_terms-Tuple{Tuple{Union{Tuple{TuringGLM.AbstractTerm, Vararg{TuringGLM.AbstractTerm, N} where N}, TuringGLM.AbstractTerm}, Vararg{Union{Tuple{TuringGLM.AbstractTerm, Vararg{TuringGLM.AbstractTerm, N} where N}, TuringGLM.AbstractTerm}, N} where N}}"><code>TuringGLM.collect_matrix_terms</code></a>, which pulls out all the terms that are matrix terms as determined by the trait function <a href="#TuringGLM.is_matrix_term-Tuple{T} where T"><code>TuringGLM.is_matrix_term</code></a>, which is true by default for all <code>AbstractTerm</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/terms.jl#L140-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.Schema" href="#TuringGLM.Schema"><code>TuringGLM.Schema</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Schema</code></pre><p>Struct that wraps a <code>Dict</code> mapping <code>Term</code>s to their concrete forms.  This exists mainly for dispatch purposes and to support possibly more sophisticated behavior in the future.</p><p>A <code>Schema</code> behaves for all intents and purposes like an immutable <code>Dict</code>, and delegates the constructor as well as <code>getindex</code>, <code>get</code>, <code>merge!</code>, <code>merge</code>, <code>keys</code>, and <code>haskey</code> to the wrapped <code>Dict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/schema.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.Star" href="#TuringGLM.Star"><code>TuringGLM.Star</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Star &lt;: FormulaRewrite end</code></pre><p>Expand <code>a*b</code> to <code>a + b + a&amp;b</code> (<code>*(a,b)</code> to <code>+(a,b,&amp;(a,b))</code>).  Applies recursively to multiple <code>*</code> arguments, so needs a clean-up pass (from distributive/associative).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/formula.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.Term" href="#TuringGLM.Term"><code>TuringGLM.Term</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Term &lt;: AbstractTerm</code></pre><p>A placeholder for a variable in a formula where the type (and necessary data invariants) is not yet known.  This will be converted to a <a href="#TuringGLM.ContinuousTerm"><code>TuringGLM.ContinuousTerm</code></a> or <a href="#TuringGLM.CategoricalTerm"><code>TuringGLM.CategoricalTerm</code></a> by <a href="#TuringGLM.apply_schema-Tuple{Any, Any}"><code>TuringGLM.apply_schema</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>sym::Symbol</code>: The name of the data column this term refers to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/terms.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Union{Tuple{T}, Tuple{C}, Tuple{TuringGLM.ContrastsMatrix{C, T, U} where U, TuringGLM.ContrastsMatrix{C, T, U} where U}} where {C&lt;:TuringGLM.AbstractContrasts, T}" href="#Base.:==-Union{Tuple{T}, Tuple{C}, Tuple{TuringGLM.ContrastsMatrix{C, T, U} where U, TuringGLM.ContrastsMatrix{C, T, U} where U}} where {C&lt;:TuringGLM.AbstractContrasts, T}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:(==)</code></pre><p>Only check equality of matrix, termnames, and levels, and that the type is the same for the contrasts (values are irrelevant).  This ensures that the two will behave identically in creating modelmatrix columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/contrasts.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{TuringGLM.ContrastsMatrix{TuringGLM.FullDummyCoding, T, U} where {T, U}}, TuringGLM.ContrastsMatrix}" href="#Base.convert-Tuple{Type{TuringGLM.ContrastsMatrix{TuringGLM.FullDummyCoding, T, U} where {T, U}}, TuringGLM.ContrastsMatrix}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Promote contrasts matrix to full rank version</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/contrasts.jl#L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.apply_schema-Tuple{Any, Any}" href="#TuringGLM.apply_schema-Tuple{Any, Any}"><code>TuringGLM.apply_schema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_schema(t, schema::Schema)</code></pre><p>Return a new term that is the result of applying <code>schema</code> to term <code>t</code>.</p><p>When <code>t</code> is a <code>ContinuousTerm</code> or <code>CategoricalTerm</code> already, the term will be returned unchanged <em>unless</em> a matching term is found in the schema.  This allows selective re-setting of a schema to change the contrast coding or levels of a categorical term, or to change a continuous term to categorical or vice versa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/schema.jl#L153-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.apply_schema-Tuple{TuringGLM.ConstantTerm, TuringGLM.FullRank, Type}" href="#TuringGLM.apply_schema-Tuple{TuringGLM.ConstantTerm, TuringGLM.FullRank, Type}"><code>TuringGLM.apply_schema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_schema(t::AbstractTerm, schema::TuringGLM.FullRank)</code></pre><p>Apply a schema, under the assumption that when a less-than-full rank model matrix would be produced, categorical terms should be &quot;promoted&quot; to full rank (where a categorical variable with <span>$k$</span> levels would produce <span>$k$</span> columns, instead of <span>$k-1$</span> in the standard contrast coding schemes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/schema.jl#L233-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.center_predictors-Tuple{AbstractMatrix{T} where T}" href="#TuringGLM.center_predictors-Tuple{AbstractMatrix{T} where T}"><code>TuringGLM.center_predictors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center_predictors(X::AbstractMatrix)</code></pre><p>Centers the columns of a matrix <code>X</code> of predictors to mean 0.</p><p>Returns a tuple with:</p><ol><li><code>μ_X</code>: 1xK <code>Matrix</code> of <code>Float64</code>s of the means of the K columns in the original <code>X</code></li></ol><p>matrix.</p><ol><li><code>X_centered</code>: A <code>Matrix</code> of <code>Float64</code>s with the same dimensions as the original matrix</li></ol><p><code>X</code> with the columns centered on mean μ=0.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: a matrix of predictors where rows are observations and columns are</li></ul><p>variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/utils.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.checkcol-Tuple{Any, Symbol}" href="#TuringGLM.checkcol-Tuple{Any, Symbol}"><code>TuringGLM.checkcol</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a nice-ish error message if the Symbol <code>name</code> isn&#39;t a column name in <code>table</code>, otherwise a zero-length string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/error_messages.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.checknamesexist-Tuple{TuringGLM.FormulaTerm, Any}" href="#TuringGLM.checknamesexist-Tuple{TuringGLM.FormulaTerm, Any}"><code>TuringGLM.checknamesexist</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check that each name in the given model <code>f</code> exists in the data source <code>t</code> and return a message if not. Return a zero string otherwise. <code>t</code> is something that implements the <code>Tables</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/error_messages.jl#L35-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.coefnames-Tuple{TuringGLM.FormulaTerm}" href="#TuringGLM.coefnames-Tuple{TuringGLM.FormulaTerm}"><code>TuringGLM.coefnames</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coefnames(term::AbstractTerm)</code></pre><p>Return the name(s) of column(s) generated by a term.  Return value is either a <code>String</code> or an iterable of <code>String</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/terms.jl#L295-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.collect_matrix_terms-Tuple{Tuple{Union{Tuple{TuringGLM.AbstractTerm, Vararg{TuringGLM.AbstractTerm, N} where N}, TuringGLM.AbstractTerm}, Vararg{Union{Tuple{TuringGLM.AbstractTerm, Vararg{TuringGLM.AbstractTerm, N} where N}, TuringGLM.AbstractTerm}, N} where N}}" href="#TuringGLM.collect_matrix_terms-Tuple{Tuple{Union{Tuple{TuringGLM.AbstractTerm, Vararg{TuringGLM.AbstractTerm, N} where N}, TuringGLM.AbstractTerm}, Vararg{Union{Tuple{TuringGLM.AbstractTerm, Vararg{TuringGLM.AbstractTerm, N} where N}, TuringGLM.AbstractTerm}, N} where N}}"><code>TuringGLM.collect_matrix_terms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collect_matrix_terms(ts::TupleTerm)
collect_matrix_terms(t::AbstractTerm) = collect_matrix_term((t, ))</code></pre><p>Depending on whether the component terms are matrix terms (meaning they have <a href="#TuringGLM.is_matrix_term-Tuple{T} where T"><code>is_matrix_term(T) == true</code></a>), <code>collect_matrix_terms</code> will return</p><ol><li>A single <code>MatrixTerm</code> (if all components are matrix terms)</li><li>A tuple of the components (if none of them are matrix terms)</li><li>A tuple of terms, with all matrix terms collected into a single <code>MatrixTerm</code>  in the first element of the tuple, and the remaining non-matrix terms passed  through unchanged.</li></ol><p>By default all terms are matrix terms (that is, <code>is_matrix_term(::Type{&lt;:AbstractTerm}) = true</code>), the first case is by far the most common.  The others are provided only for convenience when dealing with specialized terms that can&#39;t be concatenated into a single model matrix, like random-effects terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/terms.jl#L158-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.concrete_term-Tuple{TuringGLM.Term, Any, Dict{Symbol, V} where V}" href="#TuringGLM.concrete_term-Tuple{TuringGLM.Term, Any, Dict{Symbol, V} where V}"><code>TuringGLM.concrete_term</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">concrete_term(t::Term, data[, hint])</code></pre><p>Create concrete term from the placeholder <code>t</code> based on a data source and optional hint.  If <code>data</code> is a table, the <code>getproperty</code> is used to extract the appropriate column.</p><p>The <code>hint</code> can be a <code>Dict{Symbol}</code> of hints, or a specific hint, a concrete term type (<code>ContinuousTerm</code> or <code>CategoricalTerm</code>), or an instance of some <code>&lt;:AbstractContrasts</code>, in which case a <code>CategoricalTerm</code> will be created using those contrasts.</p><p>If no hint is provided (or <code>hint==nothing</code>), the <code>eltype</code> of the data is used: <code>Number</code>s are assumed to be continuous, and all others are assumed to be categorical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/schema.jl#L89-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.data_fixed_effects-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D" href="#TuringGLM.data_fixed_effects-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D"><code>TuringGLM.data_fixed_effects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">data_fixed_effects(formula::FormulaTerm, data)</code></pre><p>Constructs the matrix X of fixed-effects (a.k.a. population-level) predictors.</p><p>Returns a <code>Matrix</code> of the fixed-effects predictors variables in the <code>formula</code> and present inside <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li><code>formula</code>: a <code>FormulaTerm</code> created by <code>@formula</code> macro.</li><li><code>data</code>:  a <code>data</code> object that satisfies the</li></ul><p><a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> interface such as a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/data_constructors.jl#L18-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.data_random_effects-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D" href="#TuringGLM.data_random_effects-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D"><code>TuringGLM.data_random_effects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">data_random_effects(formula::FormulaTerm, data)</code></pre><p>Constructs the matrix(ces) Z(s) of random-effects (a.k.a. group-level) predictors.</p><p>Returns a Tuple of <code>Matrix</code> of the random-effects predictors variables in the <code>formula</code> and present inside <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li><code>formula</code>: a <code>FormulaTerm</code> created by <code>@formula</code> macro.</li><li><code>data</code>:  a <code>data</code> object that satisfies the</li></ul><p><a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> interface such as a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/data_constructors.jl#L38-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.data_response-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D" href="#TuringGLM.data_response-Union{Tuple{D}, Tuple{TuringGLM.FormulaTerm, D}} where D"><code>TuringGLM.data_response</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">data_response(formula::FormulaTerm, data)</code></pre><p>Constructs the response y vector.</p><p>Returns a <code>Vector</code> of the response variable in the <code>formula</code> and present inside <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li><code>formula</code>: a <code>FormulaTerm</code> created by <code>@formula</code> macro.</li><li><code>data</code>:  a <code>data</code> object that satisfies the</li></ul><p><a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> interface such as a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/data_constructors.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.fuzzymatch-Tuple{Any, Symbol}" href="#TuringGLM.fuzzymatch-Tuple{Any, Symbol}"><code>TuringGLM.fuzzymatch</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is borrowed from <a href=".">DataFrames.jl</a>.  Return between 0 and 2 names from <code>colnames</code> closest to <code>name</code>. <code>colnames</code> : some iterable collection of symbols</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/error_messages.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.has_schema-Tuple{TuringGLM.AbstractTerm}" href="#TuringGLM.has_schema-Tuple{TuringGLM.AbstractTerm}"><code>TuringGLM.has_schema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_schema(t::T) where {T&lt;:AbstractTerm}</code></pre><p>Return <code>true</code> if <code>t</code> has a schema, meaning that <code>apply_schema</code> would be a no-op.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/schema.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.is_matrix_term-Tuple{T} where T" href="#TuringGLM.is_matrix_term-Tuple{T} where T"><code>TuringGLM.is_matrix_term</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_matrix_term(::Type{&lt;:AbstractTerm})</code></pre><p>Does this type of term get concatenated with other matrix terms into a single model matrix?  This controls the behavior of the <a href="#TuringGLM.collect_matrix_terms-Tuple{Tuple{Union{Tuple{TuringGLM.AbstractTerm, Vararg{TuringGLM.AbstractTerm, N} where N}, TuringGLM.AbstractTerm}, Vararg{Union{Tuple{TuringGLM.AbstractTerm, Vararg{TuringGLM.AbstractTerm, N} where N}, TuringGLM.AbstractTerm}, N} where N}}"><code>TuringGLM.collect_matrix_terms</code></a>, which collects all of its arguments for which <code>is_matrix_term</code> returns <code>true</code> into a <a href="#TuringGLM.MatrixTerm"><code>TuringGLM.MatrixTerm</code></a>, and returns the rest unchanged.</p><p>Since all &quot;normal&quot; terms which describe one or more model matrix columns are matrix terms, this defaults to <code>true</code> for any <code>AbstractTerm</code>. An example of a non-matrix term is a random-effect term <a href="@ref"><code>TuringGLM.RandomEffectTerm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/terms.jl#L195-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.schema" href="#TuringGLM.schema"><code>TuringGLM.schema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">schema([terms::AbstractVector{&lt;:AbstractTerm}, ]data, hints::Dict{Symbol})
schema(term::AbstractTerm, data, hints::Dict{Symbol})</code></pre><p>Compute all the invariants necessary to fit a model with <code>terms</code>.  A schema is a dict that maps <code>Term</code>s to their concrete instantiations (either <code>CategoricalTerm</code>s or <code>ContinuousTerm</code>s.  &quot;Hints&quot; may optionally be supplied in the form of a <code>Dict</code> mapping term names (as <code>Symbol</code>s) to term or contrast types.  If a hint is not provided for a variable, the appropriate term type will be guessed based on the data type from the data column: any numeric data is assumed to be continuous, and any non-numeric data is assumed to be categorical.</p><p>Return a <a href="#TuringGLM.Schema"><code>TuringGLM.Schema</code></a>, which is a wrapper around a <code>Dict</code> mapping <code>Term</code>s to their concrete instantiations (<code>ContinuousTerm</code> or <code>CategoricalTerm</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/schema.jl#L51-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.standardize_predictors-Tuple{AbstractMatrix{T} where T}" href="#TuringGLM.standardize_predictors-Tuple{AbstractMatrix{T} where T}"><code>TuringGLM.standardize_predictors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">standardize_predictors(X::AbstractMatrix)</code></pre><p>Standardizes the columns of a matrix <code>X</code> of predictors to mean 0 and standard deviation 1.</p><p>Returns a tuple with:</p><ol><li><code>μ_X</code>: 1xK <code>Matrix</code> of <code>Float64</code>s of the means of the K columns in the original <code>X</code></li></ol><p>matrix.</p><ol><li><code>σ_X</code>: 1xK <code>Matrix</code> of <code>Float64</code>s of the standard deviations of the K columns in the</li></ol><p>original <code>X</code> matrix.</p><ol><li><code>X_std</code>: A <code>Matrix</code> of <code>Float64</code>s with the same dimensions as the original matrix</li></ol><p><code>X</code> with the columns centered on mean μ=0 and standard deviation σ=1.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: a matrix of predictors where rows are observations and columns are</li></ul><p>variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/utils.jl#L25-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.term-Tuple{Number}" href="#TuringGLM.term-Tuple{Number}"><code>TuringGLM.term</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">term(x)</code></pre><p>Wrap argument in an appropriate <code>AbstractTerm</code> type: <code>Symbol</code>s and <code>AbstractString</code>s become <code>Term</code>s, and <code>Number</code>s become <code>ConstantTerm</code>s.  Any <code>AbstractTerm</code>s are unchanged. <code>AbstractString</code>s are converted to symbols before wrapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/terms.jl#L336-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.termsyms-Tuple{TuringGLM.AbstractTerm}" href="#TuringGLM.termsyms-Tuple{TuringGLM.AbstractTerm}"><code>TuringGLM.termsyms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">termsyms(t::Terms.Term)</code></pre><p>Extract the set of symbols referenced in this term. This is needed in order to determine when a categorical term should have standard (reduced rank) or full rank contrasts, based on the context it occurs in and the other terms that have already been encountered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/schema.jl#L293-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.termvars-Tuple{TuringGLM.AbstractTerm}" href="#TuringGLM.termvars-Tuple{TuringGLM.AbstractTerm}"><code>TuringGLM.termvars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">termvars(t::AbstractTerm)</code></pre><p>The data variables that this term refers to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/schema.jl#L309-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TuringGLM.@formula-Tuple{Any}" href="#TuringGLM.@formula-Tuple{Any}"><code>TuringGLM.@formula</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@formula(ex)</code></pre><p>Capture and parse a formula expression as a <code>Formula</code> struct.</p><p>A formula is an abstract specification of a dependence between <em>left-hand</em> and <em>right-hand</em> side variables as in, e.g., a regression model.  Each side specifies at a high level how tabular data is to be converted to a numerical matrix suitable for modeling.  This specification looks something like Julia code, is represented as a Julia <code>Expr</code>, but uses special syntax.  The <code>@formula</code> macro takes an expression like <code>y ~ a*b</code>, transforms it according to the formula syntax rules into a lowered form (like <code>y ~ a + b + a&amp;b</code>), and constructs a <code>Formula</code> struct which captures the original expression, the lowered expression, and the left- and right-hand-side.</p><p>Operators that have special interpretations in this syntax are</p><ul><li><code>~</code> is the formula separator, where it is a binary operator (the first argument is the left-hand side, and the second is the right-hand side.</li><li><code>+</code> concatenates variables as columns when generating a model matrix.</li><li><code>&amp;</code> representes an <em>interaction</em> between two or more variables, which corresponds to a row-wise kronecker product of the individual terms (or element-wise product if all terms involved are continuous/scalar).</li><li><code>*</code> expands to all main effects and interactions: <code>a*b</code> is equivalent to <code>a+b+a&amp;b</code>, <code>a*b*c</code> to <code>a+b+c+a&amp;b+a&amp;c+b&amp;c+a&amp;b&amp;c</code>, etc.</li><li><code>1</code>, <code>0</code>, and <code>-1</code> indicate the presence (for <code>1</code>) or absence (for <code>0</code> and <code>-1</code>) of an intercept column.</li></ul><p>The rules that are applied are</p><ul><li>The associative rule (un-nests nested calls to <code>+</code>, <code>&amp;</code>, and <code>*</code>).</li><li>The distributive rule (interactions <code>&amp;</code> distribute over concatenation <code>+</code>).</li><li>The <code>*</code> rule expands <code>a*b</code> to <code>a+b+a&amp;b</code> (recursively).</li><li>Subtraction is converted to addition and negation, so <code>x-1</code> becomes <code>x + -1</code> (applies only to subtraction of literal 1).</li><li>Single-argument <code>&amp;</code> calls are stripped, so <code>&amp;(x)</code> becomes the main effect <code>x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/TuringGLM.jl/blob/a12a2def8fec3ff14c73b9e59e2ccff883648048/src/formula.jl#L15-L51">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 27 November 2021 13:07">Saturday 27 November 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
